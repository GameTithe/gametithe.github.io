---
title: "[알고리즘] 백준 1966번: 프린터 큐 (C++)"
date: 2025-06-26
toc: true
categories:
  - "Tistory"
tags:
  - "tistory"
---

### **내 풀이**

어떤 자료구조를 써야되나 고민을 하다가

이전 글에서 배운 deque 돌리는 방법으로 풀어봐야겠다는 생각이 들었습니다.

deque에 데이터를  pair<초기 index, 값> 로 저장했습니다.

그리고 for문을 한 번 돌면서 최대값의 초기 index를 가져왔습니다.

현재 출력하려는 data의 초기 인덱스와 우리가 원하는 초기 index(target)과 를 비교했습니다.

동일하면

그대로 출력

동일하지 않으면

deque의 pop\_front, push\_back을 사용해서 최대값을 맨 앞으로 가져오고(순서를 재배치해야되니까 ), 최대값을 pop했습니다.

혼자 뿌듯해하면서 정석풀이를 찾아보니 역시나 또 ...   
저의 풀이는 똥이였습니다..

```
#include <iostream>
#include <cstdio>

#include <deque>
#include <stack>
#include <vector>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;

    for (int i = 0; i < n; i++)
    {
        deque<pair<int, int>> data;
        int it;

        cin >> it;

        int target;
        cin >> target;

        for (int i = 0; i < it; i++)
        {
            int num;
            cin >> num;
            data.push_back({i, num });
        }

        int count = 1;

        while(true)
        {

            int start = 0;
            int index = data[0].first;
            for (int i = 0; i < data.size(); i++)
            {
                if (data[start].second < data[i].second)
                {
                    start = i;
                    index = data[i].first;
                }
            }

            if (index == target) {
                cout << count << "\n";
                break;
            }
            for (int i = 0; i < start; i++)
            {
                pair<int, int> p = data.front();
                data.pop_front();
                data.push_back(p);
            }
            data.pop_front();

            count++;
        }
           

    }


    return 0;
}
```

### **정석 풀이**

priority queue를 사용하면 간단하게 queue의 회전 조건을 검사할 수 있다.

(회전 조건:  queue 위 맨앞을 맨뒤로 보내면서 순서를 돌려주는 것을 의미)

priority에 값을 저장하면 front는 항상 최대 값(프린트 최우선)이 배치되어있고,

그 값과  queue 값을 비교하면 된다.

priority queue의 front에 있는 값보다 작으면 맨뒤로 보내고,

같으면 프린트 처리해주면 된다

```
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int T;                        // 테스트케이스 수
    cin >> T;
    while (T--) {
        int N, M;                 // 문서 수, 관심 문서 인덱스
        cin >> N >> M;

        queue<pair<int,int>> q;   // (priority, original index)
        priority_queue<int> pq;   // 현재 큐 안 최고 priority 저장
        for (int i = 0; i < N; ++i) {
            int p; cin >> p;
            q.emplace(p, i);
            pq.push(p);
        }

        int printed = 0;
        while (true) {
            auto [pri, idx] = q.front(); q.pop();
            if (pri < pq.top()) {         // 뒤로 재배치
                q.emplace(pri, idx);
            } else {                      // 인쇄
                pq.pop();
                ++printed;
                if (idx == M) {           // 목표 문서
                    cout << printed << '\n';
                    break;
                }
            }
        }
    }
    return 0;
}
```