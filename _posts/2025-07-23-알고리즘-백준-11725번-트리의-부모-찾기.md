---
title: "[알고리즘] 백준 11725번: 트리의 부모 찾기"
date: 2025-07-23
toc: true
categories:
  - "Tistory"
tags:
  - "tistory"
---

사실 주어진 입력으로 그래프를 그릴려니 그릴라면 다양하게 그릴 수 있기에 어떻게 풀라는 건지 감이 안왔다.

그래서 힌트만 살짝 얻어보니

![](https://blog.kakaocdn.net/dna/EeW8D/btsPv1VHERG/AAAAAAAAAAAAAAAAAAAAABBozQACgGFUpZtAhM0Yj79Tq8fXeSUOf_fGRveo8lUu/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=7bnAvlotQ287FRdsE42BWZRoKGE%3D)

여기서 루트가 없지만 1로 가정해라 => 1로 출발

각 노드의 부모를 구해라 => 어디서 왔는 지 출력해라

결론: bfs, dfs를 할 때 부모를 따로 저장해둬라

연습삼아 bfs, dfs 두 방법 모두 구현해보았습니다.

```
#include <iostream>
#include <queue>
#include <map>
#include <cstring>
#include <set>
#include <vector>
#include <climits>
#include <cmath>
using namespace std;

vector<int> parent(100005); 

void dfs(vector<vector<int>>& tree, vector<bool>& vis, int idx)
{ 
    for (int& node : tree[idx])
    {
        if (vis[node]) continue;

        parent[node] = idx;
        vis[idx] = true;
        dfs(tree, vis, node);
    }
}
void bfs(vector<vector<int>>& tree, vector<int>& store, vector<bool>& vis)
{
    queue<pair<int, int>> q; 
    q.push({ 1,1 });  

    while (!q.empty())
    {
        int index = q.front().first;
        store[index] = q.front().second;
        q.pop();

        if (vis[index]) continue;
        vis[index] = true;
 
        while (!tree[index].empty())
        {
            int i = tree[index].back();
            if (vis[i]) {
                tree[index].pop_back();  continue;
            }
            q.push({ i, index });
            tree[index].pop_back();            
        }
    }
}

int main()
{ 
    int n;
    cin >> n;

    vector<vector<int>> tree(n + 1);
    vector<bool> vis(n + 1); 
    vector<int> store(n + 1);

    for (int i = 0; i < n - 1; i++)
    {
        int a, b;
        cin >> a >> b;

        tree[a].push_back(b);
        tree[b].push_back(a);
    }

    //bfs(tree, store, vis);
    dfs(tree, vis, 1);

   // for (int i = 2; i < store.size(); i++)
    //    cout << store[i] << "\n";

    for (int i = 2; i <= n; i++)
        cout << parent[i] << "\n";
    return 0;
}
```