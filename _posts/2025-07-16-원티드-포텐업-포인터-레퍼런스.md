---
title: "[원티드 포텐업] 포인터 & 레퍼런스"
date: 2025-07-16
toc: true
categories:
  - "Tistory"
tags:
  - "tistory"
---

C#은 실행에 필요한 부분만 기계어로 바꾸고 나머지는 meta파일로 바꾸고, 필요할 때 기계어로 바꿔서 사용한다.

포인터를 사용하면서 절대로 잊지말아야하는 것

**포인터는 단순이 메모리 주소를 저장하는 ~~int~~ (정수형태로 관리를 한다) 변수이다. ~~( size를 찍어보면 항상 int사이즈일 것)~~**

(32비트 시스템에서는 포인터 크기가 보통 4바이트(sizeof(void\*) == 4)이고, 64비트 시스템에서는 8바이트(sizeof(void\*) == 8)이다. )

언리얼 코딩 규약에서는 pointer 크기를 추정하지 말라고한다. 그렇게 중요한건 아닌듯

![](https://blog.kakaocdn.net/dna/QmVUI/btsPm3Mo2F1/AAAAAAAAAAAAAAAAAAAAAJSOim3MYgNORfedJBYfNmZjrmjXYAEC0p5CzgvQi53d/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=rO7j427gO3gWndIn2Tz%2B5cd0PDE%3D)

**포인터는 무서운게 아닙니다. 겁 먹지 마세요**

```
#include <iostream>

#define LOG(x) std::cout << x << std::endl

int main()
{
	void* ptr = nullptr;
	std::cin.get();
}
```

포인터에 지정되는 타입이 어떻든, 포인터의 크기를 로그로 찍어보면 int크기만큼 찍힐 것이다.

void는 어떤 형태의 포인터이던지 다 받을 수 있다.

범용성을 위해서 사용할 때가 많다. ( 다형성을 사용할 수 없는경우 사용하더라)

### **다중 포인터**

```
#include <iostream>

#define LOG(x) std::cout << x << std::endl

int main()
{
	char* buffer = new char[8];
	memset(buffer, 0, 8);

	char** ptr = &buffer;

	delete[] buffer;
	std::cin.get();
}
```

다중포인터는

그냥 어떤 포인터를 가리키는 포인터라고 생각하면 쉽다.

int\* (어떤 포인터)  A= &B; 이런 느낌이다.

이걸 코드로보면 아래와 같다. 어렵게 생각하지 않았으면 좋겠다. 다중 포인터도 일반 포인터일 뿐이다.

```
int a;
int* b= &a;
int* (*c) = &b;
int* (**d)= &c;
```

이렇게 하면 오류가 날까?

```
#include <iostream>

#define Log(x) std::cout << x  << std::endl 

int main()
{
	int number = 10;
	void* pointer = &number;

	 *pointer = 20;  

	std::cin.get();
}
```

정답

더보기

오류가 난다!

pointer가 void\* 이기 떄문에 정수값을 할당할 수 없다

이렇게하면 오류가 날까?

```
char* buffer = new char[20]; 
for (int i = 0; i < 20; i++) buffer[i] = 1;

//정석
// delete[] buffer
delete buffer;
```

정답

더보기

잘 실행된다. 하지만 맞는 문법은 delete[] buffer이다.

그럼 동적할당 해제는 잘 될까?  잘 되던데? Thank you MS

memset 동작원리 알 필요가 있음, 포인터의 핵심 기능이기 때문이다.

```
memset(pointer, 시작주소, 크기)
```

포인터는 가용범위만 사용해야된다. memset과 같이 시작주소와 가용범위(크기)에 값을 저장(사용)해야된다.

class를 배우게 되면, 넘어가는 실수를 범할 수 있다. 이건 최악 of 최악의 실수. 초과해서 건드는 데이터가 무슨 데이터인지 불분명하기 때문에 어떤 에러가 생길지 모른다.

![](https://blog.kakaocdn.net/dna/oMVkg/btsPj8BjnJG/AAAAAAAAAAAAAAAAAAAAAKyRZfAn2VxdYX2uB2m14pOmdw-KXLQVOdLs81g2aZ2J/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=SGOfrlQHqIbv4HNE%2BSn0KW348Bo%3D)

### **레퍼런스 (&)**

포인터로 실수를 많이해서 레퍼런스가 등장했다. 그렇기 때문에 어셈블러 단에서는 레퍼런스와 포인터는 동일하다.

```
#include <iostream>

#define LOG(x) std::cout << x << std::endl

int main()
{
	int a = 5;
	int& ref = a;
	ref = 10;

	std::cin.get();
}
```

**사용할 때 안정성 측면에서 포인터와 차이가 있는데,**

레퍼런스가 반드시 지켜야할 제약이다.

**1. 선언할 때 이미 메모리를 차지하고 있는 변수를 참조해야 된다.**

**2.**변수를 참조해야 하기 떄문에 값을 직접 대입해 생성할 수 없다.****

**3. 초기화한 이후에는 다른 변수를 가리킬 수 없다.**

```
#include <iostream> 

int main()
{
	int number = 10;
	int temp = 20;
	// 레퍼런스는 선언과 동시에 다른 변수를 참조 
	int& ref = number;
        //int& ref2; // 선언만 하는 것 불가능 X
        //int& ref3 = 5; // 값을 직접 대입해서 생성하는 것 불가능 X 
	ref = 30;  // 값 변경 가능 O
    
    	//ref = &temp // 다른 변수의 주소 지정하도록 변경하는 것 불가능 X
    

	std::cin.get();
}
```

### 함수와 사용할 때

```
#include <iostream>

void Increase(int* numberA)
{
	*numberA++;
}

int main()
{
	int number1 = 10; 
	Increase(&number1);
}
```

이렇게 call by reference상황에서 잘 사용하시면 되구요

만약 포인터로 구현한다면 아래와 같이 구현할 수 있을 것인데

```
#include <iostream>

void Increase(int* numberA)
{
	*numberA++;
}

int main()
{
	int* number1 = 10; 
	Increase(number1);
}
```

혹시 이런 실수를 한다면 어떻게 될까?

```
void Increase(int* numberA)
{
	numberA++;
}
```

오우마이갓이다 주소가 변경되고 있다!!

이런 상황을 방지하기 위해서 사용되는게 const문법이데,

포인터는 이렇게 사용하면, 주소를 변경할 수 없다고 에러 메세지를 줄 것이다.

```
void Increase(int* const numberA)
{
	numberA++;
}
```

그럼 레퍼런스는 어떨까?

위에서 말한 제약조건 중 3번 **3. 초기화한 이후에는 다른 변수를 가리킬 수 없다.**

애초에 막아두었다 Thank you reference

### **기억할 것**

### **1.**

이게 무슨 엔디일까? => 리틀 엔디안 ( 데이터의 하위 비트가 메모리 주소 낮은 곳에 저장된다 )

![](https://blog.kakaocdn.net/dna/V25v1/btsPjAkN4zP/AAAAAAAAAAAAAAAAAAAAAGB9tyfWhRZUdEdR2ewhLemBiDj82di1vnX2c8cyBocp/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=IcleSaeBsEu4DB8Oz%2FtOCItXnr4%3D)![](https://blog.kakaocdn.net/dna/WSIjr/btsPknLJ474/AAAAAAAAAAAAAAAAAAAAADbg6Np_W6aNVKj3lyAYl-A4LVQONMvQcHCK__1FdTqI/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=9YhBu9Y87uj%2BmMaU%2B7z2V0%2FeKQg%3D)

( 주로 16진법을 사용한다. 0~9 +  A ~ F )

### 

### **2.**

```
int main()
{
	new char[8];
}
```

이렇게 했을 때 동작할까?

문법상 오류가 있나?

NO, 그럼 컴파일 가능

그러나 BUT  로직상 문제 O -> memory leak(delete를 못함)

### **3.**

둘 중 뭐가 더 좋을까?

```
1. for(int i = 0; i < 10; i++)
2. for(int i = 0; i < 10; ++i)
```

2번이 더 좋은데, 요즘 컴파일러가 좋아져서 1번을 2번으로 자동으로 바꿔줌

i++ 작동 원리는

int temp = i; i = i + 1; return temp; 처럼 동작한다.

즉, 값을 복사하고 증가하는 과정이 들어간다.

++i 작동 원리는

i = i + 1; return i; 처럼 동작하기 때문에 복사가 없다

나중에 class iterator를 사용하다보면, 복사생성자를 한 번 줄일 수 있는 좋은(얼마나 좋은지는 모름) 방법이 될 수 있을 것 같다

### **4.**

아무 설정안하면 stack을 얼마나 잡을까?

![](https://blog.kakaocdn.net/dna/BI86L/btsPj13kF2z/AAAAAAAAAAAAAAAAAAAAAGyidvVSoEkf0wP6EO4RqEVuBO5hIVJsBmp63Ipm3746/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=IT8JVmTBbXPZNd2HnLzfZIfcy4Q%3D)