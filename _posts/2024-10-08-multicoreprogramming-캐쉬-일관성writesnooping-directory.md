---
title: "[MultiCoreProgramming] 캐쉬 일관성(Write,Snooping, Directory)"
date: 2024-10-08
toc: true
categories:
  - "Tistory"
tags:
  - "tistory"
---

## **Cache Coherence Solution(캐쉬 일관성을 위한 해결책)**

**이렇게는 안할 것이다...**

**=======================================================================================**

* **캐시를 쓰지말자**
  + 모든 데이터 트래픽이 **메인 메모리**로 향하게 되어 성능 저하가 발생할 수 있다..
* **공유 데이터를 쓰지말자**
  + 이 방법은 소프트웨어적으로 단순한 해결책을 제공하지만, 성능에 **큰 페널티**가 발생할 수 있다.

**=======================================================================================**

* **동기화 지점에서 공유 데이터 **Flushing** (플러싱)하자**
  + 중요한 동기화 지점에서 캐시에 있는 **공유 데이터를 Flushing**하여 메모리 일관성을 유지하는 방법이다. 이 방법은 상대적으로 단순하지만 비용이 많이 들 수 있다. (Flusing은 캐시에 있는 데이터를 주 메모리로 쓰는(write-back) 과정이다.)
* **하드웨어 기반의 캐시 일관성(Hardware-Based Cache Coherence)**:
  + 하드웨어적으로 **명시적인 통신을 통해 일관성을 보장한다**. 이 과정은 캐시 블록 단위로 이루어지며, 필요한 경우 통신을 통해 일관성을 유지한다. (ex. MESI, MOESI)

## 

## **Write할 때 일관성을 지키는 방법**

### **1. Write-Invalidate(무효화)** - 이 방법을 많이 쓴다.

* **데이터를 수정하기 전에 해당 주소를 사용하는 모든 다른 캐시를 무효화시키는 방식입니다**.
* **쓰기 작업**이 발생할 때, **동일한 주소를 캐싱하고 있는 모든 프로세서에게 “무효화(invalidate)” 명령**을 보낸다.
* 이 방식은 **주소(address)**만을 사용하는 트랜잭션입니다.

### **2. Write-Update(업데이트)**

* **데이터를 쓰면 그 데이터를 다른 캐시에도 업데이트해서 일관성을 유지합니다.**
* **쓰기 작업**이 발생할 때, **동일한 주소를 캐싱하고 있는 모든 프로세서에게 “업데이트(update)” 명령**을 보낸다.
* 이 방식은 **주소 + 데이터**를 사용하는 트랜잭션이다.

### **Bus-Based Multiprocessor**

* 위의 두가지 방법을 Bus-Based Multiprocessor를 사용해서 효과적으로 구현할 수 있다.
* 버스는 **브로드캐스트** 매체로, 모든 버스 트랜잭션이 모든 프로세서에게 전달된다.
* 각 프로세서는 버스를 **snooping(감시)**하여 필요한 트랜잭션에 대해 캐시 일관성을 유지하기 위한 작업을 수행한다.

### **MESI 프로토콜** (캐시의 일관성을 위한 블록의 4가지 상태)

1. **M (**Modified**)**:
   * 이 블록은 **로컬 프로세서**에 의해 수정되어졌다.
   * 이 블럭이 최신값을 가지고 있다.
   * 즉, 이 블록이 최신 정보이며 메인 메모리에 반영되지 않은 변경사항이 포함되어 있다.
   * **다른 프로세서는 이 블록을 캐싱하지 않고 있다.**
   * (ex. 나는 최신 정보를 가지고 있고, 메모리와 불일치하지만 다른 프로세서들이 접근하려면 내가 먼저 메모리에 업데이를 해야된다.)
2. **E (**Exclusive**)**:
   * 이 블록은 **로컬 프로세서만 소유**하고 있으며, 다른 프로세서는 이 블록을 캐싱하지 않는다.
   * (ex. 오직 나만 가지고 있다.)
3. **S ( **Shared**)**:
   * 이 블록은 **여러 프로세서끼리 공유하고 있고**.
   * 만약 이 블록을 업데이트하려면, **다른 캐시된 복사본을 무효화하거나 업데이트**해야 한다.
   * (ex. 여러 프로세서가 공유중이다.)
4. **I (Invalid)**:
   * 이 블록은 **유효하지 않음**을 나타낸다. 즉, 더 이상 사용할 수 없는 상태이다.
   * (ex. 다른 프로세서에서 값을 고치고 싶을 때 Invalid라고 공지하고 바꾼다)

#### 

## **Coherent caches provide(**일관성있는 캐쉬가 제공하는 것)****

* **Migration (데이터 이동)**: 데이터를 한 프로세서에서 다른 프로세서로 **이동**시키는 과정입니다. 데이터가 로컬 캐시에 있어야 접근 속도가 빨라지므로, 필요에 따라 데이터를 다른 프로세서로 이동시킵니다.
* **Replication (데이터 복제)**: 동일한 데이터를 여러 프로세서의 캐시에 **복제**해 유지합니다. 이 방법은 여러 프로세서가 독립적으로 동일한 데이터를 빠르게 읽을 수 있게 하지만, 데이터가 변경될 경우 일관성을 유지하는 데 어려움이 따릅니다.

## **Cache Coherence Protocols(****캐시 일관성 프로토콜)**

* **디렉터리 기반 프로토콜(Directory-Based Protocol)**:
  + 각 메모리 블록이 **어떤 프로세서에 의해 공유되고 있는지**에 대한 정보를 **디렉터리**라는 중앙 위치에서 관리한다.
  + 장점: 불필요한 캐시 브로드캐스트를 줄여 성능을 높일 수 있다.
  + 단점: 디렉터리를 유지하는 데 비용이 많이 들고 복잡성이 증가할 수 있다.
* **Snooping 프로토콜**:
  + 각 프로세서의 캐시가 **버스를 감시**하여 어떤 데이터가 공유되고 있는지 정보를 추적(감시)한다. 버스에서 메모리 변경 사항을 감시하여 자신의 데이터를 업데이트합니다.
  + 장점: 작은 규모에서는 구현이 간단하고 효과적입니다.
  + 단점: 버스 트래픽이 증가하여 확장성에 한계가 있습니다.

## 

## **Snooping VS Directory**

### **스누핑(Snooping)**

* **브로드캐스트 메시지**에 의존한다.
* 각 노드는 **브로드캐스트 네트워크를 모니터링**하여 캐시 일관성을 유지하기 위한 요청을 감지한다.
* 요청이 있을 때, L2 캐시 태그를 조회하여 추가 작업이 필요한지 확인한다.

#### **Flow**

1. 캐시 컨트롤러가 **공유 매체(버스 또는 스위치)**에서 **모든 트랜잭션을 snooping(감시)**한다.

2. 관련 트랜잭션이 있는 경우, **일관성을 보장하기 위한 작업**을 수행한다.

3. **무효화, 업데이트 또는 값을 할당**하는 작업을 수행하며, **블록의 상태와 프로토콜에 따라 다르다.**

4. 쓰기를 수행하기 전에는 **write invalidate(MESI프로토콜 중 I로 바꾼다는 의미)** 또는 **모든 복사본을 업데이트**해야 한다. (일반적으로는 write invalidate를 수행한다.)

### **디렉터리 기반 일관성 (Directory-Based Coherence)**

* **디렉터리**는 **어떤 프로세서가 어떤 캐시 블록을 캐싱하고 있는지** 추적한다.
* 디렉터리는 중앙집중형(central) 또는 분산형(distributed)으로 나뉘며, 분산된 환경에서 각 노드가 정보를 관리할 수 있습니다.( **중앙집중형**: 하나의 중앙 디렉터리가 모든 캐시 블록 정보를 관리한다. 병목현상 발생가능                                            **분산형**: 여러 노드가 각각 디렉터리 정보를 분담. 병목 현상이 적고 확장성 좋음.)
* 디렉터리를 유지하는 데에는 **저장 공간의 오버헤드**가 발생한다.