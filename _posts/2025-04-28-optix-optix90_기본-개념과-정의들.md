---
title: "[OptiX] Optix9.0_기본 개념과 정의들"
date: 2025-04-28
toc: true
categories:
  - "Tistory"
tags:
  - "tistory"
---

우선 전체 내용을 커버할 계획은 없습니다.

지금 당장 저에게 필요한 내용을 공부하면서 기록할 예정입니다.

## Preface

Optix에서 사용되는 줄임말들입니다.

![](https://blog.kakaocdn.net/dna/pLh9j/btsNB99lJGj/AAAAAAAAAAAAAAAAAAAAAAlM-TiG7XLtgvX5B-jcxAIxuReVEv7VnwdWsfO7yaLL/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=MYlkJ%2BJbijutivglJjRZmoVVC40%3D)

Accleration structure를 통해서 rendering 되는 기하학적 요소들이 최적화 된다.

![](https://blog.kakaocdn.net/dna/bbL6WR/btsNBK9SB5z/AAAAAAAAAAAAAAAAAAAAAApEtlxgyvcmXIBlRi_zaRhi874bhS8qnnrwB6i-qDsO/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=RNYCD%2BELw4z8Jd1A10sNqObxUbs%3D)

NVIDIA Optix와 acceleration structure가 상호장용하는 내용은 shader binding table (SBT)에 저장된다.

![](https://blog.kakaocdn.net/dna/pTIib/btsNAI6ivjp/AAAAAAAAAAAAAAAAAAAAAENerX3DEfJfh6-Kyblu960FJJ86EErQ8kXTIeFzmR4l/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=pKa492tYYma8i%2FBbu%2Bb4CLt6BdM%3D)

host: application을 실행시키는 **processor**이다.

device: host와 상호작용하는 **GPU**이다.

build: host에 의해 초기화되는 device의 **acceleration structure를 생성**하는 것이다.

## Overview

Optix는 CUDA기반으로 작동됩니다. API는 stateless, multi thread, 비동기로 디자인되어 있고, 고성능 작동을 위한 제어를 지원한다.

Optix의 하나의 context는 하나의 GPU를 다룰 수 있다. 이때 contex는 CPU의 메모리를 많이 잡아먹지 않는다. (CUDA와 마찬가지로)

contex는 뿐만 아니라 expensive host-based state의 handle을 관리할 수 있다. 이 handle object는 크기가 작다. ( 100KB이하)

handle은 context가 파괴될 때 같이 파괴된다.

더보기

Host-based state는 복잡하고 무거운 설정이니까, OptiX는 그것들을 가벼운 handle로 묶어서 관리하고, context가 죽을 때 같이 정리되게 설계됐다는 느낌

Application은 acceleration structures생성(build), 컴파일, 그리고 host-device 간 메모리 전송을 호출한다.  
모든 API 함수는 **CUDA stream**을 사용하고, 가능한 경우 GPU 함수들을 비동기로 호출한다.

만약 둘 이상의 스트림을 사용할 경우, **애플리케이션은 CUDA 이벤트를 이용해 필요한 의존성을 충족시켜야 하며**, GPU 상의 경쟁 상태(race condition)를 방지해야 한다.

효율적인 작업 분산(load balancing)이나 **NVLINK를 통한 GPU 메모리 공유** 같은 멀티 GPU 기능은 **애플리케이션 개발자가 직접 처리해야 한다**.

효율성과 일관성을 위해, **NVIDIA OptiX 런타임**은 (CUDA 커널과 달리)  
**하나의 작업을 실행 도중에도 다른 lane, warp, 또는 스트리밍 멀티프로세서(SM)로 이동시킬 수 있다**.

따라서 **애플리케이션은 OptiX에 제공하는 프로그램 안에서**

**shared memory 사용, 동기화(synchronization), barrier, 기타 SM 스레드-특화(thread-specific) 프로그래밍 구조를 사용할 수 없다.**

## Basic concepts and definitions

NVIDIA OptiX에서 **program**은 DirectX Raytracing(DXR)나 Vulkan에서의 **shader** 라고 생각하면된다.

### Program and Data Model

Optix에서 제공하는 ray tracing pipline은 8가지 type의 program이 구현되어있다.

1. **Ray Generation:** ray tracing pipeline의 진입점. 각각의 pixel, sample에서 병렬로 실행된다.
2. **Intersection**: ray와 primitive가 교차하는지 확인하는 지점
3. **Any hit:** 교차됐을 때 호출
4. **Closet hit:** 가장 가까운 교차점 호출
5. **Miss:** 교차가 안되었을 때 호출
6. **Exeption:** overflow or error
7. **Direct callables:** 즉각적인 호출이 가눙한 함수
8. **Continuation callables:** 즉각적인 호출은 안되고, scheduler에 의해 실행된다.

![](https://blog.kakaocdn.net/dna/nIUSC/btsNBynZ9Dw/AAAAAAAAAAAAAAAAAAAAAO0oRov5-ryvPMM5g8rxvizi1mQ1yk7KSiSSNyfHDLvI/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=rvu85EHFBF6wZ3nXGj2K6S4RuL8%3D)

### Shader binding table

기하학적 데이터와 program(과 params)을 연결하는 table이다.

record는 shader binding table의 구성요소이다. acceleration structure가 생성될 때 선택된다.

**Record Header:** application에 비공개, 프로그램 동작(예: Intersection, Any-hit, Closest-hit)을 식별하는 데 사용된다.

**Record Data:** OptiX에 비공개. 사용자가 설정하는 데이터. 예를 들면 프로그램에 전달할 파라미터 값들을 저장.

### Ray Payload

ray의 이동 경로 동안 데이터를 주고 받는 데 사용된다.

Copy-in/ Copy-out 방식으로 값이 전달되고 반환된다.

페이로드 값 수는 제한되어 있고, 로컬 메모리나 글로벌 메모리(application이 관리하는)로 연결할 수도 있다

### Primitve attributes

**primitive attributes는** **Any-hit/Closest-hit 프로그램** 으로 데이터를 전달하는 데 사용된다.

삼각형에서의 교차는 (U, V)라는 **barycentric coordinates(질량 중심 좌표계)**를 기본으로 제공한다.

사용자가 직접 정의한 교차 프로그램은 추가 속성을 일부 정의할 수 있다.

### Buffer

**버퍼(buffer)** 는 GPU 메모리를 가리키는 **포인터**이다.

NVIDIA OptiX 6과 달리, **OptiX 9에서는 버퍼의 메모리 할당과 전송이 모두 사용자 코드에 의해 명시적으로 제어**되어야 한다.

### Acceleration Structures

GPU에 생성되는 비공개 데이터 구조이다. 보통은 BVH 모델을 기반으로 한다.

OptiX에서는 두 가지 기본 가속 구조 타입을 제공한다:

**Geometry Acceleration Structures:** 삼각형, 곡선, 구, 또는 사용자 정의 primitive로 생성된다.

**Instance Acceleration Structures** 인스턴스마다 고정 변환(static transform)을 적용할 수 있다.

### Opacity Micromaps

NVIDIA OptiX 불투명 마이크로맵은 **GPU** 에서 생성되는 비공개 구조다.

하나의 삼각형에 대해 **세밀한 정보**를 지정할 수 있다

### Traversing the Scene Graph

**광선(ray)이 지오메트릭 데이터와 교차하는지 판단하려면**,  
OptiX는 **acceleration structure와 transformations 노드로 구성된 그래프를 탐색(traversal)** 한다.

이 그래프를 구성하는 각 노드를 **"traversable object"** 라고 부른다.

**Traversable object의 종류:**

* instance acceleration structure
* geometry acceleration structure (단일 구조로 루트가 될 수 있음)
* Static transform
* Matrix motion transform
* SRT motion transform

![](https://blog.kakaocdn.net/dna/Z7OZ2/btsNBshjPyW/AAAAAAAAAAAAAAAAAAAAAN0_MHMjBXgNbgv23fnguUFKgt5JEJ68xhaOzs3nXnRz/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=WrI%2BwrBMxNb6N57SyGTJrALuwqU%3D)

### Ray tracing with NVIDIA OptiX

OptiX에서 레이 트레이싱 시스템은 4단계로 구성된다

1. **acceleration structure 생성**
   * 하나 이상의 지오메트리 메쉬 또는 그 인스턴스에 대해 acceleration structure를 만든다.
2. **program pipeline생성**
   * ray tracing 중 호출될 모든 program을 포함하는 파이프라인을 만든다.
3. **shader binding table 생성**
   * program과 param을 참조하는 SBT을 만든다.
   * 데이터 레이아웃은 인스턴스 및 지오메트리와 잘 맞아야 한다.
4. **device-side kernel 실행**
   * 많은 thread들을 이용해 optixTrace를 호출하는 **Ray generation program을** 실행시켜 탐색을 시작한다.

ray tracing  은 다른 CUDA 작업과 **섞어서 병렬로 실행 가능**하다. (데이터 생성, 전송, 다른 그래픽 API로 이동 등)

**GPU 작업 전체를 조율하는 책임은 사용자에게 있다.**

OptiX는 다른 작업과 자동 동기화를 해주지 않는다.