---
title: "[C++] A* 알고리즘"
date: 2024-11-21
toc: true
categories:
  - "Tistory"
tags:
  - "tistory"
---

A\*알고리즘을 다익스트라 알고리즘을 발전시킨 알고리즘입니다.

 

다익스라 알고리즘을 그림으로 예를 들면

1번 경로로 최단거리를 찾은 후, 2번3번도 경로 탐색을 하는데 도착 지점과 멀어지는 것을 확인해도 일단 코스트가 얼마나 드는지 확인을 해봅니다. 이를 보완한 것이 A\*알고리즘입니다.

![](https://blog.kakaocdn.net/dna/baGLjI/btsKRQqvJcA/AAAAAAAAAAAAAAAAAAAAADqpnx8IhxfFnvRgl3T1DiIRaLwYqDz8PwNEH-ge4KiR/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=YA8y1R5PksE255gt7hUaW6StFeE%3D)

 

 

A\*에는 Heuristic cost function( **f(n)** )이 존재합니다.f(n) = g(n) + h(n)입니다.

g(n): 출발 노드에서 현재 노드 n까지 도달하기 위한 최단 비용

h(n): 현재 노드n에서 목표 노드까지의 예상 이동 비용

f(n): g(n)(출발~현재) + h(n)(현재 ~ 예상이동비용)

 

h(n)을 측정하는 방식 중 대각선으로 이동하는 것을 고려하지 않은 Manhattan distance를 사용하겠습니다.

Mahattan distance는 대각이동은 고려하지 않는 방법이기에 시작지점(p1,p2), 도착지점(q1,q2)일 때, 거리를 |p1 -q1|+|p2 – q1|로 정의합니다.

![](https://blog.kakaocdn.net/dna/xc5H3/btsKQvAUXK1/AAAAAAAAAAAAAAAAAAAAAHgdqlT508Vom3VXNvjjM_mzkw7W0q5RH5VJjiBoyQX6/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=%2FgjqgSJ1rGxHmhjFboRVa8UB75w%3D)![](https://blog.kakaocdn.net/dna/bdfyRY/btsKPCgs2pi/AAAAAAAAAAAAAAAAAAAAAAfoBk8cUTpd-u2Lnuly_RbiPCCrEWrTR-LXJ4L_FYPt/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=rrLhXaZ4JoCtSczeAHFqJ8r%2FAGI%3D)

'

그리드를 위에와 같이 표현하겠습니다. 한 칸당 비용을 10으로 했을 때입니다.

한 칸에 f, g,h,를 그림과 같이 표시합니다.

Start에 우측에 칸을 예씨로 들면, 우측칸에서 Target까지 5칸을 가야합니다. 그렇기 때문에 h는 50입니다. Start (현재위치)에서 우측까지 1칸 이동해야됩니다. 그래서 g는 10입니다. f = g + h 이므로, f는 60으로 표기했습니다.

 

openlist, closelist라는 개념을 추가하고 뒷 내용을 이어가겠습니다. 탐색할 곳은 openlist, 탐색이 끝난 곳은 closelist에 넣는다고 표현하겠습니다.

 

Start의 주변 경로를 탐색했으니, Start는 closelist에 넣습니다. 그리고 탐색한 경로 중 f의 값이 가장 작은 값을 A라고 하겠습니다. A를 openlist에 넣고 주변을 탐색합니다. 탐색한 후에는 A도 closelist에 넣습니다.

 

이렇게 반복…하면 됩니다.

위의 내용을 정리하면 ( 글만.. ㅎㅎ 유뷰트 고라니TV 참조했습니다. 색이 있는 글씨는 대각선까지 계산하는 것입니다. )

![](https://blog.kakaocdn.net/dna/cegwM6/btsKQKqY0iI/AAAAAAAAAAAAAAAAAAAAANKIGDSTOrcbx_TroPbJmCfFpDPUosiRUsl4ZoeXxx7R/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=rdCBBdhIAqBBg9BYPjKKW4r7l7Y%3D)

글씨로 보면 간단하고, 구현을 해봐도 어렵지 않습니다.

우선 openList에서 search할 Node들을 넣었다가, 가까 cost가 낮은 Node들을 먼저 꺼내서 searching합니다.

그럼 priority\_queue를 사용하면, 쉽게 구현할 수 있습니다.

**근데...**

우선순위 큐로 거의 모든 것을 구현했는데,

우선순위 큐로는 "openList에 이웃노드가 없다면" 이 조건을 수행하기가 까다롭습니다. (search할 함수가 구현이 안되어있습니다.)

**그래서 중간에 Set을 바꿔줬습니다. set도 정렬되어있는 자료구조이고, search까지 할 수 있기 때문입니다. 또한 길찾기에서는 중복되는 값이 한 번에 들어갈 일이 없기 때문에 적합하다고 생각했습니다.**

목표를 찾고, 다시 parent Node를 역추적해서 찾은 길을 도출해냅니다. **이때 vector를 사용하면 reverse를 해줘야되니**

**deque의 push\_front로 대체해줍니다.**

```
set<Node*, greater<Node*>> openList;
deque<Node> load;
```

**그리고 closeList는 boolean으로 대체했습니다.**

closeList에 들어가는 조건은 방문을 했을 때이니 boolean으로도 충분할 것이라고 생각했습니다.

또한 벽도 같이 처리할 수 있으니 1석 2조입니다.

이제 함수 구현으로 가보겠습니다.

먼서 map, 인덱스(x,y 좌표), parent Node 저장 , ... 등등 고려할게 많은 struct, class를 잘 이용해봅시다.

GridPos는 x,y표를 담당하도록 만들어줬고, operator를 사용해서 좌표 연산을 쉽게 해줬습니다.

( -를 희안하게 해준것 같은데, 나중에 멘헤튼 거리 계산할 때만 - 연산을 사용하니 그 용도에 맞게 만들어준것입니다. )

```
struct  GridPos
{
	int x;
	int y;

	int operator-(const GridPos& rhs)
	{
		return abs(x - rhs.x) + abs(y - rhs.y);
	}

	bool operator==(const GridPos& rhs)
	{
		return ((x == rhs.x) && (y == rhs.y));
	}
};
```

각각의 Node들은 좌표(GridPos), closed (boolean), 부모 Node, f ,g ,h 를 가지고 있습니다.

closed(boolean)은 closeList에 넣는 대신 Node의 활성화, 비활성화를 담당합니다.

boolean만 체크해서 이동가능한지 불가능한지 판단합니다. ( 벽도 이것만 비활성화 해주면 간단히 처리가능합니다.)

**노드를 탐색할 때 f 값과 h값으로 판단하기 때문에 operator를 오버로딩해줬습니다.**

```
class Node
{
public:
	Node() {}
	Node(GridPos gp, bool bClosed) : index(gp), closed(bClosed) {}
	Node(GridPos gp) : index(gp), m_g(0), m_h(0), m_f(0) {}
	Node(GridPos gp, int g, int h, int f) : index(gp), m_g(g), m_h(h), m_f(f) {}
	GridPos index;
	//GridPos parent = GridPos{ -1, -1 };
	Node* parent = nullptr;

	bool operator>(const Node& other) const
	{
		if (m_f == other.m_f)
			return m_h < other.m_h;

		return m_f > other.m_f;
	}
	int m_g, m_h, m_f;

	bool closed = false;
};
```

대각선 방향은 계산을 안하니, 맨헤튼 거리 식을 사용합니다. ( 가로 + 세로 ) \* 이동비용입니다.

close함수는 node의 close를 세팅 + openList에서 지우는 함수입니다.

두 행동을 같이 해줘야되는데, 혹시 실수할 수 있으니 함수로 묶어줍니다.

```
int CalManhattanDist(Node* start, Node* target)
{
	return distValue * (start->index - target->index);
}
void close(Node* node)
{
	node->closed = true;
	openList.erase(node);
}
```

드디어 A\* 알고리즘 시작입니다.

시작, 타겟 위치를 저장하고 A\*알고리즘을 시작합니다.

```
void FindPathUsingAStar()
{
	
	Node* start  =  map[cameraGridPos.y][cameraGridPos.x];//new Node{ cameraGridPos, 0, 0, 0 };
	start->m_g = 0;
	Node* target =  map[goalGridPos.y][goalGridPos.x];//new Node{ goalGridPos };

	openList.emplace(start);


	FindPathUsingAStar(*openList.begin(), start, target);

	return;
}
```

주석과 글씨를 보면 구현할 수 있을 것입니다.

![](https://blog.kakaocdn.net/dna/cegwM6/btsKQKqY0iI/AAAAAAAAAAAAAAAAAAAAANKIGDSTOrcbx_TroPbJmCfFpDPUosiRUsl4ZoeXxx7R/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=rdCBBdhIAqBBg9BYPjKKW4r7l7Y%3D)

```
void FindPathUsingAStar(Node* cur, Node* start, Node* target)
{
	if (openList.empty())
		cout << "Damger approch" << endl;
	//open에서 1개 제거 이미 사용할 건  node에 저장되어있음  
	
	while (true)
	{
		close(cur);
		if (cur->index == target->index)
		{
			cout << "Path found!" << endl;

			Node* node = cur;
 			while (node != nullptr)
			{
				load.push_front(node->index);
				node = node->parent; 
			} 
			break;  // Break out of the while loop instead of returning

		}

		int x = cur->index.x;
		int y = cur->index.y;

		cout << "Search Index :" << x << ", " << y << endl;
		//4방향 탐색을 위한 배열
		int dx[4] = { -1, 1 , 0, 0 };
		int dy[4] = { 0 ,0, -1, 1 };

		 
		// 갈 수 있는 4방향 값들을 초기화
		for (int i = 0; i < 4; i++)
		{
			int newX = x + dx[i];
			int newY = y + dy[i];
			if (newX < 0 || newX >= MazeSize) continue;
			if (newY < 0 || newY >= MazeSize) continue;
			// 벽 or closedList
			if (map[newX][newY]->closed) continue;
			
			Node* adj = map[newX][newY];  

			adj->m_h = CalManhattanDist(cur, target);
			adj->m_g = cur->m_g + distValue;
			adj->m_f = adj->m_f + adj->m_g;
			adj->parent = cur;
		}

		//4방향 탐색
		for (int i = 0; i < 4; i++)
		{
			int newX = x + dx[i];
			int newY = y + dy[i];
			
            // 갈 수 없는 위치
			if (newX < 0 || newX >= MazeSize) continue;
			if (newY < 0 || newY >= MazeSize) continue;
			// 벽 or closedList
			if (map[newX][newY]->closed) continue;

			//이동비용 < adj의 g ||
			//open에 이웃노드가 없다면 
			//g,h 부모 설정 후 openlist에 추가

			//이동비용 < adj의 g
			Node* adj = map[newX][newY];
			bool costCheck = distValue > adj->m_f;

			//open에 이웃노드가 없다면 
			bool neighborCheck = openList.find(adj) == openList.end();

			//g,h 부모 설정 후 openlist에 추가
			if (costCheck || neighborCheck)
			{
				// h는 mahattanDist 함수로 결정한다.
				// g 는 이전 node의 g + 1칸 이동할 떄 value로 결정한다.
				// f = h + g로 결정한다. 
				adj->m_h = CalManhattanDist(cur, target);
				adj->m_g = cur->m_g + distValue;
				adj->m_f = adj->m_f + adj->m_g;
			
				adj->parent = cur;
			
				openList.emplace(adj);
			}
		}

		cur = *openList.begin(); 
	} 
}
```

실행 화면입니다.

<https://tithingbygame.tistory.com/116>