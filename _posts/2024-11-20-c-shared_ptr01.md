---
title: "[C++] shared_ptr(01)"
date: 2024-11-20
toc: true
categories:
  - "Tistory"
tags:
  - "tistory"
---

보통 메모리를 동적할당할 때 아래와 같은 코드로 많이 구현을 했을 것이다.

```
#include <iostream>

using namespace std;

void main()
{
	int* ip = nullptr;
	ip = new int;
	*ip = 3;
	
	cout << *ip << endl;

	delete ip;
}
```

(게임 개발할 때는) 이렇게 new, delete를 직접 이렇게 관리하는 것은 위험하다.

아래의 상황을 보자

KTest는 다른 곳에서 사용되고 있는 포인터를 참조하는 ipRef를 관리하는 클래스라고 생각하자.

```
#include <iostream>

using namespace std;

class KTest
{
private:
	//내가 할당한 포인터X
	//다른 곳에서 사용되고 있는 포인터를 참조하는 용도
	int* ipRef;

public:
	KTest()
	{
		ipRef = nullptr;
	}
	
	void SetRefData(int *ip)
	{
		ipRef = ip;
	}	

	int GetData() const
	{
		return *ipRef;
	}
};
void main()
{
	int* ip = nullptr;
	ip = new int;
	*ip = 3;
	
	KTest t;
	t.SetRefData(ip);
	cout << "KTest T: " << t.GetData() << endl;

	delete ip;

}
```

그럼 main 함수를 봤을 때 현재는 아무문제가 없다.

![](https://blog.kakaocdn.net/dna/bxa3Tc/btsKPVyOgXA/AAAAAAAAAAAAAAAAAAAAAFVp-I_UgXSvs93dzIxRiIYzb2yI-bynXNCCuJJNoL62/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=X0vMqWfwogB6kBSx%2BZRX5cZpHXo%3D)

4

출력도 잘된다. 하지만 delete ip가 호출되고 나서

KTest가 한 번더 ipRef에 접근하면 어떻게 될까?

아래와 같이 main이 구성되면 KTest가 참조하고 있는 데이터가 동적할당해제가 되어버린다.

```
void main()
{
	int* ip = nullptr;
	ip = new int;
	*ip = 3;
	
	KTest t;
	t.SetRefData(ip);
	cout << "KTest T: " << t.GetData() << endl;

	delete ip;
	
	cout << "KTest T: " << t.GetData() << endl;

}
```

![](https://blog.kakaocdn.net/dna/cvdbPn/btsKOUnkKoJ/AAAAAAAAAAAAAAAAAAAAAOimOKfnEkIPjy6vFYOuws7m8I1LOdJMX3Q9iSnDM1OM/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=jSSKMygUgIZjtDTecRL6TaWyNms%3D)

i**pRef는 이미 해제된 포인터를 가리키고 있으니  dangling 포인터**가 되고, 값 역시 쓰레기 값이 나오게된다.

이를 해결하기 위해서 smart pointer가 등장한 것이다.

스마트 포인터를 사용하는 것은 일반 포인터와 크게 다르지 않다.

shared\_ptr로 바꿔주기만 하면된다. ( smart pointer에는 shared, weak, unique가 있지만 여기서는 shared를 중점적으로 다룬다.)   
아래의 코드와 주석을 보면 직관적으로 보일 것이다. (std::shared\_ptr가 스마트 포인터인것이다.)

일반 포인터였다면

t가 참조하고 있는 ip가 reset (delete)이 되었기 때문에 t.IsSafeData는 false를 반환 할 것이다. **(일반 포인터였다면)**

```
KTest t;
t.SetRefData(ip);
cout << "KTest T: " << t.GetData() << endl;

//delete ip;
ip.reset();

if( t.IsSafeData() )
	cout << "KTest T: " << t.GetData() << endl;
```

하지만 실행시켜보면 "KTest T: 3" 이 2번 호출되는 것을 볼 수 있다.

![](https://blog.kakaocdn.net/dna/SXqhP/btsKOU1Yfy7/AAAAAAAAAAAAAAAAAAAAAI55k-nztpRURfkaIHT3azp5La0-_4QHzy9gxl2fG9fz/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=94gWLFSg8BBw6dQCSPfNg4AdGCA%3D)

shared\_ptr은 내부적으로 **ref count**라고 존재한다. 나를 참조하고 있는 객체가 존재하는지 세고 있는 것이다.

**ref count가 0이되어야지, 비로소 나를 참조하고 있는 애가 없구나! 생각하고 메모리 해제가 되는 것이다.**

```
#include <iostream>

using namespace std;

class KTest
{
private:
	//내가 할당한 포인터X
	//다른 곳에서 사용되고 있는 포인터를 참조하는 용도
	std::shared_ptr<int> ipRef;

public:
	KTest()
	{
		//스마트 포인터는 생성자에서 null로 초기화가 자동으로 된다.
		//ipRef = nullptr;
	}
	
	void SetRefData(shared_ptr<int> ip)
	{
		ipRef = ip;
	}	

	int GetData() const
	{
		return *ipRef;
	}
	void Release()
	{
		ipRef.reset();
	}
	bool IsSafeData() const
	{
		if (ipRef)
			return true;

		return false;
	}
};
void main()
{
	//int* ip = nullptr;
	//ip = new int;
	//*ip = 3;
	
	std::shared_ptr<int> ip = make_shared<int>(3); 

	KTest t;
	t.SetRefData(ip);
	cout << "KTest T: " << t.GetData() << endl;

	//delete ip;
	ip.reset();

	if( t.IsSafeData() )
		cout << "KTest T: " << t.GetData() << endl; 

}
```

이렇게 Release를 만들어서 테스트해보자

```
class KTest
{
	...
	void Release()
	{
		ipRef.reset();
	}
	...
}
```

t마저 Release를 해준다면 ipRef를 참조하고 있는 객체가 아무도 없기 때문에

ref count가 0이되고, ipRef는 null이 되고, IsSafeData()가 fase을 반환하게 된다.

```
int main()
{
	t.Release();
	
	if( t.IsSafeData() )
		cout << "KTest T: " << t.GetData() << endl;
}
```

![](https://blog.kakaocdn.net/dna/ddaqgq/btsKNXZrGlQ/AAAAAAAAAAAAAAAAAAAAAPB8J-qmt-1uwr9EIE0jJbrQIaNJWLYbrNMcXVSNHNni/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=bbKhfdZ1lXYYze34IO%2BAPxKEnQ4%3D)

출력 코드를 1개 더 추가했지만 여전히 2줄만 출력된다.