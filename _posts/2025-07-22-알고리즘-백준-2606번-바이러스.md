---
title: "[알고리즘] 백준 2606번: 바이러스"
date: 2025-07-22
toc: true
categories:
  - "Tistory"
tags:
  - "tistory"
---

그래프 문제를 처음 풀어봤다.

그래도 잘 푼 것 같은데 계속 답이 틀리게 나왔다.

그 이유는 양방향 설정을 안해줬기 때문이였다람쥐...

```
#include <iostream>
#include <queue>
#include <map>
#include <cstring>
#include <set>
#include <vector>
#include <climits>
#include <cmath>
using namespace std;
 
void dfs(vector<vector<int>>& couple, bool* vis, int idx)
{
    if (vis[idx]) return;
 
    vis[idx] = true;

    if (couple[idx].empty()) return;
        
    for (int i : couple[idx])
        dfs(couple, vis, i);
}
int main()
{ 
    int numOfComputer;
    cin >> numOfComputer;

    vector<vector<int>> couple(numOfComputer + 1, vector<int>(0));
    bool vis[101] = {false};

    int numOfCouple;
    cin >> numOfCouple;
    for (int i = 0; i < numOfCouple; i++)
    {
        int a, b;
        cin >> a >> b; 
        couple[a].push_back(b); 
        couple[b].push_back(a); 
    }

    int max = 0; 
    
    dfs(couple, vis, 1); 
    for (int i = 2; i <= numOfComputer; i++)     
    {
        if (vis[i]) max++;
    }

    cout << max; 
    return 0;
}
```