---
title: "[알고리즘] 백준 2346번: 풍선 터뜨리기 (C++)"
date: 2025-06-25
toc: true
categories:
  - "Tistory"
tags:
  - "tistory"
---

[2346번: 풍선 터뜨리기](https://www.acmicpc.net/problem/2346)

내가 푼 방법..

하나 하나 예외저리를 했다.

queue, deque : 맨 앞, 뒤의 데이터만 조작할 수 있으니 부적합하다고 생각

stack: 맨 뒤 데이터만 조작할 수 있으니 부적합하다고 생각

그래서 vector로 만들어서 예외저리

```
#include <iostream>
#include <cstring>

#include <vector> 
#include <deque>

using namespace std;
   
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
	 
    int n;
    cin >> n;

    vector<int> vec(n + 1,0);

    for (int i = 1; i <= n; i++)
    { 
        int t; 
        cin >> t;
        vec[i] = t;
    }
      
    int now = 1;  
    cout << now << " ";

    while (true)
    {
        int next = now;
        int op = vec[now];
        vec[now] = 0;
        
        for (int i = 1; i <= n + 1; i++)
        {
            if (i == n + 1) return 0;
            if (vec[i] != 0) break;
        } 
        if (op > 0)
        {
            for (int i = 0; i < op; i++)
            {
                next = next + 1;
                if(next == n + 1) next = 1;
                if (vec[next] == 0) i--;
            }
        }
        
        else
        {
            for (int i = 0; i > op; i--)
            {
                next = next - 1;
                if (next == 0) next = n;
                if (vec[next] == 0) i++;
            }

        }

        now = next;
        cout << now << " " ;
    }
   
}
```

정석(?) 풀이

맨 앞에 있는 값을  pop하는 것으로  가정을 해서

deque를 만들어서 데이터를 회전(?)시키면 된다.

이렇게 하면 맨 앞, 맨 뒤의 데이터 조작만으로 문제해결이 가능

![](https://blog.kakaocdn.net/dna/c9SsQK/btsOQRmrZrY/AAAAAAAAAAAAAAAAAAAAAN1qY1VqZREjJNRLm-5eCoHu9eiWt7-afPXrMr-vspRm/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=lMJb%2BFOn29har%2FG9UcJshgvwW7k%3D)![](https://blog.kakaocdn.net/dna/l0hRM/btsOQUpM5UZ/AAAAAAAAAAAAAAAAAAAAANgjHbbiXpAjfgOjAeD-26sSjsmC7dX7_a2TIafZEp3M/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=wRpUhwoskjoVRjz4Xp475vr%2BaYM%3D)

```
#include <iostream>
#include <deque>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;
    cin >> N;

    deque<pair<int, int>> dq; // {index, value}
    for (int i = 1; i <= N; ++i) {
        int num;
        cin >> num;
        dq.emplace_back(i, num);
    }
    

    while (!dq.empty()) {
        int idx = dq.front().first;
        int move = dq.front().second;
        dq.pop_front();

        cout << idx << ' ';

        if (dq.empty()) break;
         
        if (move > 0) { 

            for (int i = 0; i < move - 1; ++i) {
                dq.push_back(dq.front());
                dq.pop_front();
            }
        }
        else { 
            for (int i = 0; i < -move; ++i) { 
                dq.push_front(dq.back());
                dq.pop_back();
            }
        }
    }

    return 0;
}
```