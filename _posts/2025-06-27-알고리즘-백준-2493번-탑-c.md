---
title: "[알고리즘] 백준 2493번: 탑 (C++)"
date: 2025-06-27
toc: true
categories:
  - "Tistory"
tags:
  - "tistory"
---

**내 풀이**

이중 for문을 쓴다는 불안감과 백준 골드 문제에 대한 실망감

이를 반기는 시간초과... 또르륵

해결하기위한 힌트:

시간초과를 해결하기 위해서는  pair를 통해 인덱스와 값을 저장하면서

for문을 돌지 않도록 내 앞에 긴 녀석만 남겨놓고있어야한다.

```
#include <iostream>
#include <stack>
#include <queue>
#include <vector>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;

    vector<int> tower(n + 1, 0);


    for (int i = 1; i <= n; i++)
    {
        int height;
        cin >> height;
        tower[i] = height;

        int std = tower[i];
        int other = i - 1;
        
        while (true)
        {
            if (std <= tower[other])
            {
                cout << other << " ";;
                break;
            }
            else if (other == 0)
            {
                cout << "0 ";
                break;
            }
            else if (std > tower[other])
            {
                other--;
            }
        }
    }
     




    return 0;
}
```

**정석 풀이**

현재 인덱스에서의 height 보다 크거나 같은 녀석만 stack 보관하고 있으면 된다.

현재 인덱스 보다 height가 낮은 녀석들은 어차피 가려질 것이다.

그래서 현재 인덱스보다 height가 낮은 녀석들은 계속 pop을 해준다.

pop을 하다가 empty가 되면 0인 거고

pop을 중단했는데 empty가 아니면 height가 높은 것을 찾은거닌 top으로 출력해주면된다.

```
#include <iostream>
#include <stack>
#include <queue>
#include <vector>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n;
    cin >> n;

    stack<pair< int, int>> tower;


    for (int i = 1; i <= n; i++)
    {
        int height;
        cin >> height;

        if (tower.empty()) cout << "0 ";
        
        else
        { 
            while (!tower.empty() && tower.top().second < height) tower.pop();
            
            if (tower.empty()) cout << "0 ";
            else cout << tower.top().first << " "; 
                
               
        }

        tower.push({ i , height });
    }
     




    return 0;
}
```