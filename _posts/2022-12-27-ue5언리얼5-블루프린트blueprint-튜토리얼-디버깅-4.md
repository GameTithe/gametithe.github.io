---
title: "[UE5/언리얼5] 블루프린트(BluePrint) 튜토리얼 - 디버깅 #4"
date: 2022-12-27
toc: true
categories:
  - "Tistory"
tags:
  - "언리얼5 #UE5 #언리얼일지 #사칙연산 #0출력 #언리얼변수 #언리얼공부 #언리얼독학 # 언리얼입문 #언리얼디버깅 #디버그 #언리얼브레이크포인트 #언리얼breakpoint #디버그 #디버깅 #breakpoint"
---

BreakPoint 단축키 : F9

(BreakPoint : 디버깅을 위한 장치로 BreakPoint를 설정해 둔 곳에서 실행이 멈춘다. 이해를 못했어도 그냥 읽어 내려가보 자)

**디버깅 하는 법을 설명하기 전에 1가지 예시를 설정하면서, 언리얼에서 사칙연산할 때 주의할 사항을 설명하고 가겠다.**

기본설정

Hp = 82

MaxHp = 100

현재 남은 체력이 몇 % 남았는지 알기 위한 코드이다

![](https://blog.kakaocdn.net/dna/QqMlT/btrUMQn2pRH/AAAAAAAAAAAAAAAAAAAAADIXzPFN5FVChDaNt0w5M3eu_BNZfONiC0jOXA7GYxxf/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=FJ72KnZ1IDF9Vr9tgmVWrOPnB2Y%3D)

이렇게 실행해보자.

기댓 출력값은 : HP = 82% 였지만

실제로는 HP = 0%가 나온다

![](https://blog.kakaocdn.net/dna/beMFU7/btrUGqYIoiZ/AAAAAAAAAAAAAAAAAAAAAF6ozJG2nLmXK3wOC90a_zdPDtS9m9_NxMuvYvywuHHJ/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=ooCLQ%2FwveXiToFZ4VvmeOERyquE%3D)

왜 이런 결과가 나오는지 C/C++로 코딩을 해본 사람이며 알 것이고, 안해봤다면 모를 것이다.

C/C++ 에서 산수를 할 때 int 와 int 를 연산하면 결과 값은 int형으로 반환된다.

그렇기 때문에 위와 같이 실행될 때 HP / MaxHp의 **계산 값이 0.82**이지만,

int 형으로 반환 되기 때문에 **결과 값은 0**이 되는 것이다.

(0.xx를 int형으로 출력하면 소수점 부분이 사라지고 0이 출력된다.)

(result를 계산할 때 naxHp를 float형으로 캐스팅하냐 안하냐의 차이가 있다.)

![](https://blog.kakaocdn.net/dna/cCzV9z/btrUMOKyGfr/AAAAAAAAAAAAAAAAAAAAAHsd8gWaTaolU-QYVIZ7rmlM4VxNqUmEoZGfnTKZ0uHQ/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=Jc3lHogqXKWNzo4pSCpW5vFBVco%3D)

![](https://blog.kakaocdn.net/dna/tsJL8/btrUM38zeEq/AAAAAAAAAAAAAAAAAAAAAGWxyNVQlAbc2DXrQoqByWhXqWVlJzeY6d_CPAMx0fC0/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=LFXYr0R9ruS2RElm9408YvwH2HM%3D)

위의 코드와 같이 실행한다면

1번 코드의 결과값 : 0

2번 코드의 결과값 : 0.82

이 나온다. 이것이 언리얼에서도 똑같이 적용되는 것이다.

(실행은 본인이 해 보자.)

다시 언리얼로 넘어와서

0으로 출력되는 버그를 해결하기 위해서는

int와 int 를 계산하는 것이 아니라, int 와 float를 섞어주면 된다.

그림과 같이 말이다.

![](https://blog.kakaocdn.net/dna/enyuiw/btrUExDMZFA/AAAAAAAAAAAAAAAAAAAAAHDBlPST5enwziTmK9uNenQppBcN_SGmiHxSoiCWcb6B/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=fwGN4eFzoQKtH9WawwHSpdxURvk%3D)

이렇게 하고 실행하면

![](https://blog.kakaocdn.net/dna/bSyK6Z/btrUImByGYf/AAAAAAAAAAAAAAAAAAAAAMdfMrhQ6wBK6fwPuyenqxdloVlh6T6C4KsbyjVPdyxF/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=ReCAypQ2V7u4dffVKLfLEYpazN8%3D)

잘 출력된다.

이렇게 작동되는 이유는 위에 올린 코드와 같다.

이제 디버깅하는 법을 설명하겠다.

확인하고 싶은 곳을 클릭하고 f9을 누르면 빨간 점이 생긴다.

그게 BreakPoint이다.

![](https://blog.kakaocdn.net/dna/vPD0t/btrUNp4OuPp/AAAAAAAAAAAAAAAAAAAAAE3MrePX57Y9_mm39KbUjLtQA_1U6HebqealIyG9PsNd/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=TQlhhAAJsfNyLir6eQnPk0ybI6o%3D)

빨간 점에 생겼으면 실행을 해보자.

![](https://blog.kakaocdn.net/dna/dvtbEf/btrUIgBk46b/AAAAAAAAAAAAAAAAAAAAAP09Agmd5zVnZ2HZKFStzn4V6yGAj75T90IpHeoiY9jU/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=uVzajBocrgbCqtMo0G6CPkVYeqY%3D)

이렇게 정지한 곳을 화살표로 알려준다.

우리가 0%로 출력되던 것을 확인하기 위해서 커서를 반환 인자에 올리면, 이렇게 반환해주는 값을 알려준다.

그럼 /(나누기) 연산이 잘 못 되었다는 것을 알 수 있다.

![](https://blog.kakaocdn.net/dna/b3hqeF/btrUKXVxspi/AAAAAAAAAAAAAAAAAAAAALz3spmuI-L7afM4y57-2GiqrMVRVPDlZJGmuC6mH6Hb/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=8x1GO0zVlqLiOWRPTyN9LV5cTyA%3D)

아래 BP를 간단하게 설명하면

메인(DevMap)에서 FuncA을 호출하고  
FuncA가 FuncB를 호출하고

FuncB가 FucC을 호출하는 것이다

Debug에서 Blueprint Debugger을 누르면

![](https://blog.kakaocdn.net/dna/k9adV/btsAot7kCdU/AAAAAAAAAAAAAAAAAAAAAPSkdt5Kw-vo6ZidyWrKiltGPwVzbsdPiCFPPjz0N6TJ/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=6dNz8RBQyX1xJvzWNA%2Fqi3CC6pc%3D)

이렇게 콜 스택을 볼 수 있다.

![](https://blog.kakaocdn.net/dna/JBEdz/btsAnAZ6rN5/AAAAAAAAAAAAAAAAAAAAAJft5wKnTlouRJXr5H4i5pUzovnz_kFMQGrseSvEYMKa/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=f3jRYtUlRchtbY41C1KuqzAz6EQ%3D)

위에서 설명한 것처럼 DevMAp ->FunA -> FuncB를 호출하는 것을 볼 수 있다

( FuncC가기 전에 breakPoint를 잡아서 FuncC는 나타나지 않은 것이다)

이때

F10 또는 F11로 BP를 전진시키면서 볼 수 있는데 차이점이 존재한다

직접하면서 체득하는 것이 좋지만, 간단하게 설명하면  
F10은 앞에 함수가 존재하면, 그 함수 속까지는 들어가지 않는다. (실행은 되지만 디버그하러 들어가지는 않는다는 의미)

F11은 앞에 함수가 존재하면, 그 함수 속까지 들어가서 디버그할 수 있다.

정리하면 앞에 존재하는 함수가 믿을만 하면 F10으로 지나가고

                                                   의심되면 F11로 함수 안으로 들어가보면 된다.