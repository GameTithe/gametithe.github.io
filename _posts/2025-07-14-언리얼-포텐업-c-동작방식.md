---
title: "[언리얼 포텐업] C++: 동작방식"
date: 2025-07-14
toc: true
categories:
  - "Tistory"
tags:
  - "tistory"
---

오전 ~ 오후: OT

1-2시간 분량

자기소개서 -인사팀 -> 기술 내용이 디테일하지 않아도 됨

포폴 - 팀 -> 실력 어필

### **DLL (Dynamic-Link Library):**

DLL은 실행파일(.exe)와 별개로 컴파일되서, 런타임에 메모리에 로드되는 공유 라이브러리다.

**동작방식:**

1. 프로그램 실행시 OS가 필요한 DLL을 메모리에 로드한다

2. 실행 중  필요한 함수나 데이터의 포인터를 통해서 DLL에서 참조한다.

3. 하나의 DLL을 여러 프로세스가 동시에 사용(공유)할 수 있다.

**장점**

1. 코드와 library 메모리가 분리되기 때문에 실행파일(.exe)파일의 크기를 줄일 수 있다.

2. 업데이트가 용이하다.

3. 하나의 DLL을 여러 프로세스가 동시에 공유할 수 있다.

**단점**

1. DLL이 손상되거나, 찾을 수 없거나, 버전이 안맞으면 프로그램이 실행되지 않음.  잘 실행되다가도 연결이 끊기면 프로그램 다운

2. 의존성 관리가 필요

언리얼 엔진의 dll 예시

![](https://blog.kakaocdn.net/dna/c1QjU6/btsPiH3Y0B8/AAAAAAAAAAAAAAAAAAAAAL0EB_OxEH_V9qVlErE6xbBK7azhr4xFtN0OirOkL464/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=0H9NQhoF5hM1UmHsSXOE7zV5aqc%3D)

### **Static Library (.lib)**

정적 라이브러리는 컴파일 시점에 실행파일(.exe)에 포함되어져서 하나의 실행 파일로 만들어지는 라이브러리다.

**동작 방식**

1. 컴파일할 때 필요한 함수들이 .lib에서 복사되어서 실행파일(.exe)안에 포함된다.

**장점**

1. 배포가 간단함 (실행파일에 모두 포함되어있으니 의존성 관리 X)

2. 런타임 안정성 (DLL처럼 외부 모듈 누락 문제 X)  
3. 디버깅이 쉬움

**단점**

1. 실행파일(.exe)파일의 크기 증가

2. 중복 메모리 사용 (여러 프로그램에서 동일한 .lib을 사용하더라도, 각자 포함되어서 중복으로 생성된다.)  
3. 업데이트 불편 (라이브러리 변경 시 전체 재빌드 필요)

결국 framework의 비대해지만, exe파일이 커지는 것을 방지하는게 좋아서 사용엔진은 dll을 많이사용한다.

이거 보고 정리하자

<https://www.youtube.com/watch?v=n0GK-9f4dl8>



<https://kfgd.tistory.com/9>

[[C++ 입문자에서 벗어나기]Chapter\_1: 타입(Type)#3

[C++ 입문자에서 벗어나기]Chapter\_1: 타입(Type)#3 이번 포스팅에서는 문자와 문자열 그리고 typedef 사용법에 대해서 이야기해 볼 것입니다. 더불어 참조타입에 대해서도 이야기하겠지만 간단히 언급

kfgd.tistory.com](https://kfgd.tistory.com/9)

<https://coding-restaurant.tistory.com/472>

[비주얼스튜디오 문자집합(유니코드 vs 멀티바이트)

비쥬얼스튜디오에 생성된 프로젝트에서 마우스 우클릭하여 속성>구성 속성>고급에 들어간다. 문자 집합 설정을 보면 유니코드 문자 집합 사용, 멀티바이트 문자 집합 사용 모드를 볼 수 있다.

coding-restaurant.tistory.com](https://coding-restaurant.tistory.com/472)

언리얼도 문자열 타입이 목적별로 3개로 나눠져있다.

![](https://blog.kakaocdn.net/dna/HeDx8/btsPiH31VMC/AAAAAAAAAAAAAAAAAAAAABiiRwmrwAkj3TAKVMWCfmFPUGovqtsuQTFOEIcOLJbh/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=6BpQvH8IznkDsmLwHrKxRm0OdJg%3D)

### **1. 전처리 단계 ( Preprocessing)**

**주요 작업:**

1. #include 헤더 파일 삽입 ( 주로 #으로 시작되는 것들 )

2. #define, #ifdef 등 전처리 매크로 처리 ( 주로 #으로 시작되는 것들 )

3. 주석 제거

**결과적으로 순수 C/C++ 소스 코드 파일 생성된다.**

**여기서는 문법 오류를 검사하지 않는다.**

### **2. 컴파일 단계**

1. 컴파일은 cpp 파일만 (h는 안한다, #include에서 추가될 것) 확인하면서 실행된다.

(cpp에 아무 내용이 없어도 일단 obj를 만든다. cpp가 200개면 obj도 200개 생성

-> 어셈블 찍고 obj지만, 어셈블러를 따로 보여주는게 아니니 그냥 obj로 작성함)

2. 구문 분석 (문법 분석, 구문 오류 확인, 사실상 이게 전부)   
3. 최적화 (inline함수 대체, 불필요한 코드 제거  등)

4. 코드를 어셈블러 코드로 변환 ( 아키텍처에 맞게 컴파일러가 변환 )

-> 아키텍처에 맞게 번역을 해준다고 봐도 됨

### **3. 어셈블리 단계**

어셈블러가

어셈블리어 코드를 기계어 바이너리로 바꿔 .obj 파일 생성

### **4. 링크 단계 (linking)**

**주요 작업:**

1..cpp 파일간 의존성이 있다면, obj 파일들을 링킹해준다. (원래는 obj 파일이 200개면 200개를 다 뒤져본다. -> 근데 요즘에는 최적화를 조금 시킨듯)

위의 단계에서 많이 시간을 잡아먹는게 컴파일이다.

그렇기 떄문에 컴파일 시간을 줄이는게 중요하다.

실행파일에서 컴파일 시간이 중요하지 않지만 (유저는 몰라잉) ,

프로그래머 입장에서는 컴파일 시간을 줄여야 효율적으로 작업할 수 있는 것이다.

**-> 전방선언을 잘 활용하는 것이 거의 유일한 방법**

소소한 내용

더보기

컴파일러 오류( C어쩌구)는 사실 명확해서 잡기 편함

근데 linker 오류(LNK 어쩌구)는 잡기 어려움 ... ;;;

**기억해둘 것들**

오늘 배운건 다 인지하고 있어야 될 것 같다.