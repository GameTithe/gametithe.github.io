---
title: "[UE5/언리얼5] Tag 디버깅 할 때 ( 기본적인 방법 & Actor 만들어보기 )"
date: 2024-12-23
toc: true
categories:
  - "Tistory"
tags:
  - "tistory"
---

우선 GAS을 사용하다 보면 Tag에 따라 게임이 진행되는 경우가 많기 때문에 Tag 디버깅하는 방법을 공유하겠다.

1. 기본적으로 제공되는 방법

게임을 플레이한다. -> ' 를 누른다 -> F8을 눌른다 -> tag를 보고 싶은 Actor를 클린한다.

그럼 아래와 같은 화면이 나올 것이다.

1, 2번을 눌러서 AI, BehaviorTree를 끄고, 3번을 눌러서 Abilities를 활성화 시킨다.

![](https://blog.kakaocdn.net/dna/bVbJYg/btsLskTVZpm/AAAAAAAAAAAAAAAAAAAAAIpxa6LRSK_xT0WOt2i1wtXWkQvxdRJiStYmKUbZy5UZ/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=7%2FAmmQlCaF1a%2BJV25%2BApTJhLxHc%3D)

그러면 아래와 같이 Tag를 확인할 수 있다.

![](https://blog.kakaocdn.net/dna/HNPTE/btsLuwMnQFw/AAAAAAAAAAAAAAAAAAAAAMeCC73mDZPrVYl7kM5spL6y7Rb8QW0GHnaMH5Xad5LW/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=B%2B%2BuVpNZLEgFn93a4Uy2wD5qc18%3D)

이 과정을 계속하는 것이 번거롭거나 제한되는 상황일 수 있으니 Tag Printer를 만들어보았다.

2. Tag Printer

trigger된 Actor의 Tag를 출력해주는 간단한 디버깅 툴이라고 보면된다.

아래와 같이 간다하게 구성되어있다. ( Tag Render Component를 사용해서 tag를 출력한다. )

![](https://blog.kakaocdn.net/dna/q0JGh/btsLs0N71nd/AAAAAAAAAAAAAAAAAAAAAJNao0ey8yOF4ME7CwYGd94a3b_p0hUzUENxS-5u03tc/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1772290799&allow_ip=&allow_referer=&signature=7hyoUHudGL647MkCnIFBypS2kVI%3D)

### **1.  Overlap에 내가 만든 함수를 추가해주자**

```
// Called when the game starts or when spawned
void ADebugTag::BeginPlay()
{
	Super::BeginPlay();

	BoxComponent->OnComponentBeginOverlap.AddDynamic(this, &ThisClass::PrintPawnTags);
	BoxComponent->OnComponentEndOverlap.AddDynamic(this, &ThisClass::StopPrintingTags);
}
```

처음에는 Print하는 함수 자체를 Add했었지만, 문제가 하나 있다.

만약에 Overlap이 되는 순간에는 Tag가 없지만, 2초 뒤에 Tag가 생긴다면 ??  
  
이런 상황에서는 BeginOverlap에서 Tag를 Print하면 안된다.

그렇기 때문에 BeginOverlap에서는

1. boolean으로만 print가능한지 체크

2. Overlapㄸ된 Actor, ASC 저장

만 하였다.

EndOverlap에서는   
1. boolean, Actor, ASC 초기화

```
void ADebugTag::PrintPawnTags(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	bPrint = true;
	OverlapActor = OtherActor;
	OverlapASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(OverlapActor.Get());

}
```

```
void ADebugTag::StopPrintingTags(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	bPrint = false;
	OverlapActor = nullptr;
	OverlapASC = nullptr;
}
```

### **2. 위에서 세팅한 정보를 바탕으로 출력**

Tag는 IGameplayTagAssetInterface를 상속받고 있기 때문에, 이를 이용해서 TagContainer에 접근(모든 Tag들이 저장되어 있는 곳 )

TagContainer에 접근해서 TagsName에 이름을 저장한다. 그리고 SetTags( Tag출력하는 함수 ) 를 호출해준다.

```
if (bPrint && OverlapActor.Get() != nullptr)
{

	if (IGameplayTagAssetInterface* TagInterface = Cast<IGameplayTagAssetInterface>(OverlapASC))
	{
		FGameplayTagContainer TagContainer;
		TagInterface->GetOwnedGameplayTags(TagContainer);

		TagsName.Empty();

		for (auto Tag : TagContainer)
		{
			if (TagsName.AddUnique(Tag.ToString()))
			{
				SetTags();
			}

		}
	}
}
```

TagName배열에 Tag이름을 저장하고, 3초 뒤에 지우는 알고리즘이다.

SetTags

```
void ADebugTag::SetTags()
{
	GetWorld()->GetTimerManager().ClearTimer(ResetTagTimer);
	GetWorld()->GetTimerManager().SetTimer(
		ResetTagTimer,
		this,
		&ThisClass::ResetTags,
		3.0f,
		false
	);

	SetTextToTagName();
}
```

SetTextToTagName

```
void ADebugTag::SetTextToTagName()
{
	FString AllTagsText; 

	for (FString Tag : TagsName)
	{
		AllTagsText += Tag + '\n';
	}
	TagsText->SetText(FText::FromString(AllTagsText));
}
```

이렇게 구현하면 아래와 같이 디버깅을 편하게 할 수 있다.